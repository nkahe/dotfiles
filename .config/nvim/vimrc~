" Load plugins {{{1

" "hover" information when you move the mouse over a symbol in a buffer.
" May affect scrolling in terminal.
" let g:ale_set_balloons = 1

" Plugins will be downloaded under the specified directory.
call plug#begin('~/.vim/plugged')

" =============== Plugins after this ===============

" Asynchronous linting/fixing for Vim and Language Server Protocol (LSP)
" integration. https://github.com/w0rp/ale
Plug 'w0rp/ale'

" https://github.com/jiangmiao/auto-pairs
Plug 'jiangmiao/auto-pairs'

" Auto close (X)HTML tags https://github.com/alvan/vim-closetag.
Plug 'alvan/vim-closetag', { 'for': 'html' }

Plug 'chrisbra/Colorizer', { 'for': 'css' }

" Comment stuff out. gcc, gc in visual / operator pending mode.
" https://github.com/tpope/vim-commentary
Plug 'tpope/vim-commentary'

Plug 'smancill/conky-syntax.vim', { 'for': 'conkyrc' }

" CtrlP. https://github.com/ctrlpvim/ctrlp.vim
Plug 'ctrlpvim/ctrlp.vim'

" CSS3 syntax (and syntax defined in some foreign specifications) support for
" Vim's built-in syntax/css.vim. https://github.com/hail2u/vim-css3-syntax
Plug 'hail2u/vim-css3-syntax', { 'for': 'css' }

" makes the command-line mode behave more like the Unix command line, by
" adding Emacs-style mappings (like in the Bash shell
" Plug 'houtsnip/vim-emacscommandline'

" Helpers for UNIX. https://github.com/tpope/vim-eunuch
" Plug 'tpope/vim-eunuch'

Plug 'othree/html5.vim', { 'for': 'html' }

Plug 'nathanaelkane/vim-indent-guides'

Plug 'pangloss/vim-javascript', { 'for': 'javascript' }

" Lightline.vim: A light and configurable statusline/tabline for Vim.
" https://github.com/itchyny/lightline.vim
Plug 'itchyny/lightline.vim'

" NeoVim has these by default.
if !has('nvim') | runtime macros/matchit.vim | endif

" neomutt.vim/ftplugin at master · neomutt/neomutt.vim
" https://github.com/neomutt/neomutt.vim/tree/master/ftplugin
Plug 'neomutt/neomutt.vim', { 'for': ['muttrc', 'mail'] }

" NERDTree. https://github.com/scrooloose/nerdtree
Plug 'scrooloose/nerdtree'

" vim-nerdtree-tabs: NERDTree and tabs together in Vim, painlessly.
" https://github.com/jistr/vim-nerdtree-tabs
" Plug 'jistr/vim-nerdtree-tabs'

" Replace text with the contents of a register
" https://github.com/vim-scripts/ReplaceWithRegister
Plug 'vim-scripts/ReplaceWithRegister'

" Provide filetype-dependent templates for new file.
" https://github.com/ap/vim-templates.
" setf <filetype> on empty file or New <filetype>.
Plug 'ap/vim-templates'

" Vim-cool disables search highlighting when you are done searching and
" re-enables it when you search again. https://github.com/romainl/vim-cool
" Plug 'romainl/vim-cool'

" Quoting/parenthesizing made simple. https://github.com/tpope/vim-surround
Plug 'tpope/vim-surround'

" En tiedä, toimiiko.
function! BuildYCM(info)
  if a:info.status ==? 'installed' || a:info.force
    !./install.py --ts-completer
  endif
endfunction

Plug 'Valloric/YouCompleteMe', { 'do': function('BuildYCM') }

" List ends here. Plugins become visible to Vim after this call.
call plug#end()

" Keep Plugin commands between vundle#begin/end.
" All of your Plugins must be added before the following line
" call vundle#end()

let mapleader = ','

" Map to all most common modes.
function! MapAll(key, command)
  exec 'nnoremap' a:key a:command
  exec 'inoremap' a:key '<C-o>' . a:command
  exec 'snoremap' a:key '<esc><C-o>' . a:command
endfunction

" Same but do identical mappings to Insert and Select modes.
function! MapAllIdent(key, command)
  exec 'nnoremap' a:key a:command
  exec 'inoremap' a:key '<C-o>' . a:command
  exec 'snoremap' a:key '<C-o>' . a:command
endfunction

" CtrlP {{{1

  " ! Ignored patterns are at local_rc.vim !

  let g:ctrlp_map = '<C-p>'

  " MRU = Most Renent Used files
  call MapAll('<A-m>',':CtrlPMRU<CR>')
  call MapAll('<A-b>',':CtrlPBuffer<CR>')

  " Make work in some other modes.
  " inoremap <silent> <C-p> <Esc>:set noinsertmode \| :CtrlP<CR>
  " snoremap <silent> <C-p> <Esc>:set noinsertmode \| :CtrlP<CR>

  " search in Files, Buffers and MRU files at the same time by default.
  let g:ctrlp_cmd = 'CtrlPMixed'

  " Use caching
  let g:ctrlp_use_caching = 1

  " The first option tells ctrlp to persist the cache in the configured location, so when you
  " launch vim again, it will read from there and load the cache (much faster).
  let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'

  " Enter avaa uudessa tabissa, C-t nykyisessä.
  "let g:ctrlp_prompt_mappings = {
  "\ 'AcceptSelection("e")': ['<c-t>'],
  "\ 'AcceptSelection("t")': ['<cr>', '<2-LeftMouse>'],
  "\ }

  " Etsi tiedostonimien, eikä koko polun perusteella.
  let g:ctrlp_by_filename = 1

  " Follow symlinks
  let g:ctrlp_follow_symlinks = 1

  " Show hidden files
  let g:ctrlp_show_hidden = 1

  " Järjestä tiedostot ylhäältä alas.
  let g:ctrlp_match_window = 'bottom,order:btt'

  " By default open in new buffer
  " let g:ctrlp_switch_buffer = 0

  " "Unless a starting directory is specified, set dir according edited file.
  let g:ctrlp_working_path_mode = 'c'

  let g:ctrlp_switch_buffer = 'Et'
" When opening file, enter jumps to that file if it's already open somewhere.
" Ctrl-t only if it's in current tab.

" Huom! CtrlPMixed + hakemisto ei toimi.

" Autopairs {{{1

" Off by default.
let b:autopairs_enabled = 0

" filenames like *.xml, *.html, *.xhtml, ...
" These are the file extensions where this plugin is enabled.
let g:closetag_filenames = '*.html,*.xhtml,*.phtml'

" filenames like *.xml, *.xhtml, ...
" This will make the list of non-closing tags self-closing in the specified files.
let g:closetag_xhtml_filenames = '*.xhtml,*.jsx'

" filetypes like xml, html, xhtml, ...
" These are the file types where this plugin is enabled.
let g:closetag_filetypes = 'html,xhtml,phtml'

" filetypes like xml, xhtml, ...
" This will make the list of non-closing tags self-closing in the specified files.
let g:closetag_xhtml_filetypes = 'xhtml,jsx'

" integer value [0|1] This will make the list of non-closing tags case-sensitive
" (e.g. `<Link>` will be closed while `<link>` won't.)
let g:closetag_emptyTags_caseSensitive = 1

" Shortcut for closing tags, default is '>'
"
" let g:closetag_shortcut = '>'

" Add > at current position without closing the current tag, default is ''
"
" let g:closetag_close_shortcut = '<leader>>'

" }}}1
" Lightline {{{1

" Show these plugins in Mode if they are active.
" Ei näyttänyt insert/normal enää.
function! LightlineMode()
  return expand('%:t') ==# 'ControlP' ? 'CtrlP' :
        \ lightline#mode()
endfunction
" \ 'component_function': {
" \   'mode': 'LightLineMode',
" \ },

" hakasulkeet näyttävät, että osat kuuluvat samaan elementtiin.
let g:lightline = {
  \ 'colorscheme': 'jellybeans',
  \ 'active': {
  \   'left': [ [ 'mode', 'paste' ],
  \             [ 'readonly', 'filename', 'modified' ] ],
  \   'right': [ [ 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
  \ },
  \ 'component_visible_condition': {
  \   'readonly': '(&filetype!="help"&& &readonly)',
  \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))'
  \ },
  \ 'separator': { 'left': '', 'right': '' },
  \ 'subseparator': { 'left': '', 'right': '' }
  \ }

if $TERM ==? 'linux'   " On TTY.
  let g:lightline.separator = { 'left': '', 'right': '' }
  let g:lightline.subseparator = { 'left': '|', 'right': '|' }
  let g:lightline.colorscheme = '16color'
endif

" }}}1
" NERDTree {{{1

nnoremap <Leader>n :NERDTreeToggle<CR>

" Open NERDTree at GUI startup?
" let g:nerdtree_tabs_open_on_gui_startup=0

"let g:NERDTreeHijackNetrw=0

" automatically close NerdTree when you open a file:
" let NERDTreeQuitOnOpen = 1

" Automatically delete the buffer of the file you just deleted with NerdTree:
let NERDTreeAutoDeleteBuffer = 1

" Open when starting Vim.
" autocmd vimenter * NERDTree

" }}}1
" Other plugins {{{1

" -- ALE -- ! Lang specific settings are in ftpplugins !

cnoreabbrev fix ALEFix
nnoremap <Leader>d :ALEDocumentation<CR>
nnoremap <Leader>fr :ALEFindReference<CR>
nnoremap <Leader>gd :ALEGoToDefinition<CR>
nnoremap <Leader>h :ALEHover<CR>

" Language specific settigs are in ftpplugin/
let g:ale_fixers = {
\   '*': ['remove_trailing_lines', 'trim_whitespace'],
\}

" Don't use project specific but global executables for all linters
let g:ale_use_global_executables = 1

" Only run linters named in ale_linters settings.
" "let g:ale_linters_explicit = 1

" failing executable checks will be cached, along with successful ones. This
" behaviouris off by default, because it means you have to restart Vim to run
" linters after you install them.
let g:ale_cache_executable_check_failures = 1

" -- Netrw -- (default). Many columns of files for netrw.
let g:netrw_liststyle = 2

" -- Vim-javascript --
augroup javascript_folding
    au!
    au FileType javascript setlocal foldmethod=syntax foldnestmax=1
augroup END

"--- YouCompleteMe ------
nnoremap <leader>yd :YcmCompleter GetDoc<CR>

" }}}1
" Misc settings {{{1
" ! '~' doesn't work properly if we are root!

" Source only if file exists and is readable.
function! SourceIfExists(file)
  if !empty(glob(a:file))
    exe 'source' a:file
  endif
endfunction

 " Sourced from in vim/autologin.
 " Use script that comes with (Neo)Vim to set familiar settings.
call SourceIfExists('$DOTFILES/vim/mswin.vim')

" Mappings for exotic key combos.
" call SourceIfExists('$DOTFILES/opensuse-defaults.vim/')

" Local computer specific settings. 'autoload' dir is synced.
call SourceIfExists('~/.vim/local.vim')

" Source personal settings that are not meant to 'official' settings.
" source $DOTFILES/vim/personal.vim

" NeoVim doesn't source this by default unlike Vim. Useful?
" if has('nvim') | silent! source /etc/vimrc | endif

" Notice: Don't need set 'syntax on' or 'ftp indent on' since VimPlug takes care of that.

" Skip if running NeoVim since it has these settings by default.
if !has('nvim')
  set autoindent     " Keep indentation from previous line
  set autoread       " when a file has changed on disk, just load it. Don't ask.
  set history=10000  " Set maximum command history
  set hlsearch
  set incsearch      " show search matches as you type
  set laststatus=2   " Statusline is always showns
  set nocompatible   " Get easier to use and more user friendly vim defaults
  set smarttab       " let's tab key insert 'tab stops', and bksp deletes tabs.
  set ttyfast        " Indicates a fast terminal connection.
  set wildmenu       " Better command-line completion
endif

set clipboard=unnamedplus  " Use system clipboard. unnamed = 'select' (3rd mouse button)  clipboard.
set confirm                " Instead of failing a command because of unsaved changes,
                           " ask if you wish to save changed files.
set foldmethod=marker      " Folding method. Use markers by default.
set linebreak              " Wrap long lines preserving word.
set modelines=1
set nostartofline          " Stop certain movements from always going to the first character of a line.
set noswapfile nobackup    " no swap files or backups
set scrolloff=7            " leave space before and after cursor when scrolling.
set shortmess+=filmnrxoOtT " Shorter messages. (no 'hit enter')
set splitbelow splitright  " New splits open below and right.
set virtualedit+=block,onemore  " allow the cursor to go anywhere in visual block mode and beyond last character.

" Use mouse on all modes unless we are in TTY.
if has('mouse') | set mouse=a | endif

" backspace and cursor keys wrap to previous/next line. FIXME ? This is also in
" mswin.vim
set backspace=indent,eol,start whichwrap+=<,>,[,]

" Tab and indenting
set expandtab      " use spaces instead of tabs.
set tabstop=2      " Number of spaces that a <Tab> in the file counts for.
set shiftwidth=2   " Indent by n spaces when using >>, <<, == etc
set softtabstop=2  " Indent by n spaces when pressing <TAB>.
set smartindent    " Intellegently dedent / indent new lines based on rules.
set shiftround     " tab / shifting moves to closest tabstop.

" Settings for web development
" autocmd Filetype html,css setlocal tabstop=2 softtabstop=2 shiftwidth=2

" Searching
set ignorecase     " case insensitive search...
set smartcase      " but ff there are uppercase letters, become case-sensitive.
set showmatch      " live match highlighting
" set gdefault       " use the `g` flag by default. Replaces whole line.

"Hides buffers instead of closing them. You can have unwritten changes to a file
" and open a new file using :e, without being forced to write or undo your changes
" first. Also, undo buffers and marks are preserved while the buffer is open.
" set hidden

" First Tab press (or whatever your wildchar is set to) will expand a filename
" or command in command mode to the longest common string it can, and a second
" press will display a list of all possible completions above the command line.
"set wildmode=longest,list
set wildmode=longest,full,full   " Show selectable menu with one tab

" Do not show some common non-text files.
set wildignore+=*.odt,*.odp,*.ods,*.xml,*.xls,*.db,*.jpeg,*.jpg,*.gif,*.png,*.pdf,*.PDF
set wildignore+=*.doc,*.docx,*.rtf,*.ppt,*.iso,*.gz,*.tgz,*.mkv,*.flv,*.srt,*.ctb,*.mp3

" Ei toimi: Lataa asennukset, kun .vimrc sisältö muuttuu.
"augroup myvimrc
"    au!
"    au BufWritePost ".vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc,init.vim so $MYVIMRC "| if has('gui_running') | so $MYGVIMRC | endif
"augroup END

" Avatessa tiedosto käytä jo avattua jos sellainen on. Huomioi tabit jos
" sellaisia on. Avaa uudessa tabissa.
set switchbuf=useopen,usetab,newtab

" No annoying sound on errors
set noerrorbells novisualbell t_vb= timeoutlen=500
autocmd GUIEnter * set vb t_vb=

" Appearance {{{1

"hi Statusline guifg=39 guibg=17

" Fancier appearance if we are not in TTY.
if $TERM !=? 'linux'
  if has('termguicolors')|set termguicolors|endif  " Truecolors
  colorscheme solarized8_dark_flat
  " Non-visible characters used with 'set list'.
  set listchars=tab:>▸,trail:~,extends:⫸,precedes:⫷,nbsp:␣,eol:¶
  let g:ale_sign_error = '✘'
  let g:ale_sign_warning = '⚠'
  let NERDTreeDirArrows = 1
else  " On TTY need to use basic settings.
  colorscheme oma
  set listchars=tab:>\ ,trail:·,extends:>,precedes:<,nbsp:+,eol:$
  " Disable different NeoVim cursors since it doesn't work on TTY.
  set guicursor=
endif

" Show trailing whitespace:
" highlight ExtraWhitespace ctermbg=darkblue guibg=darkblue
" match ExtraWhitespace /\s\+$/

set colorcolumn=          " No column to show where line should end.
set foldcolumn=1          " Column in left showing folds.
set helpheight=30         " Make help screen bigger
set lazyredraw            " Don't redraw while executing macros (good performance config)
set noshowmode            " Don't show '--INSERT--', LightLine takes care of that.
set number                " Show current line number
set previewheight=5       " Small preview window
set relativenumber        " Show relative line numbers
set shortmess+=I          " Turn offf start-up message

if has('linebreak')
  try
    set breakindent       " Visually indent wrapped lines
    let &showbreak='↳'
  catch /E518:/
    " Unknown option: breakindent
  endtry
endif

"}}}1
" Misc autocommands {{{1

augroup filetypedetect
    autocmd! BufRead,BufNewFile *.html setfiletype html
    autocmd! BufRead,BufNewFile .followup,.article,.letter,/tmp/pico*,nn.*,snd.*,/tmp/mutt* setfiletype mail
    autocmd! BufRead,BufNewFile *conkyrc setfiletype conkyrc
  augroup END

" Set file type as mail for ftplugin.

" Delete hidden buffers
" "autocmd BufEnter * setlocal bufhidden=delete

" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

" Return to last edit position when opening files - Amir Salihefendic
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

" For setting terminal tab title
if &term ==? 'screen' | set t_ts=^[k | set t_fs=^[\ | endif

" elseif has('gui_running')
"     let editorname = 'Gvim'
" else
"     let editorname = 'Vim'
" endif

function! Set_title()
  " Terminator, xfce-terminal: asettaa sekä ikkunan että tabin otsikon.
  " For Konsole / Yakuake check next function.
  " FIXME Ei toimi variablet.
  if has('nvim')
    let g:editor_name = 'NeoVim'
  else
    let g:editor_name = 'Vim'
  endif
  if &filetype ==? 'mail'
    let &titlestring = 'compose mail'
  else
    " Set terminal title
    if @% ==? ''
      let &titlestring = g:editor_name
      " let &titlestring = 'Vim'
    else
      let &titlestring = g:editor_name . " " . expand("%:t")
      " let &titlestring = 'Vim: ' . expand("%:t")
    endif
  endif
  set title
endfunction

function! Set_qt_title()
  " Set terminal tab title by bash script. Yakuakella käytä tätä.

  if @% ==? ''  " If filename is empty.
    " Run external script with 'editor' as parameter.
    " :silent !set_tab_title "Vim"
    " :!set_tab_title editorname
    " TODO: toteuta editorin nimi variableilla, jotka testataan vain kerran.
    if has('nvim')
      " let editorname = "NeoVim"
      silent !set_tab_title "NeoVim"
    else
      " let editorname = "Vim"
      silent !set_tab_title "Vim"
    endif
  else
    " %:t = Expand tail of the file name (last component of the name)."
    :silent !set_tab_title "%:t"
  endif
endfunction

" Set window and terminal tab titles unless we are on tty or GUI.
if &term !=? 'linux' || !has('gui_running')
  " $TERMINAL is defined in titles.zsh. TODO: terminaalin todennus vimscriptillä?
  if $TERMINAL ==? 'yakuake' || $TERMINAL ==? 'konsole'
    autocmd BufEnter * call Set_qt_title()
  else
    autocmd BufEnter * call Set_title()
  endif
endif
" Keymappings {{{1

" This before command = don't save to registers.
noremap - "_

" Paste selected text to command line.
" snoremap <C-l> <C-o>y:<C-r>"

" Make :W -> :w safe way
cnoreabbrev <expr> W ((getcmdtype() is# ':' && getcmdline() is# 'W')?('w'):('W'))
cnoreabbrev <expr> Q ((getcmdtype() is# ':' && getcmdline() is# 'Q')?('q'):('Q'))

" Set working dir to dir of current file and display the path.
nnoremap <Leader>cd :cd %:p:h<CR>:pwd<CR>

" Toggle invisible invisible characters
nnoremap <Leader>i :set list!<CR>

" Save if needed and open the file in the default application,
" like opens *.html in a browser.
nnoremap <silent> <Leader>o :update<Bar>silent !xdg-open %:p &<CR>

" Is in mswin.vim but makes it work in different modes.
call MapAll('<C-s>',':update<CR>')

" New shortcuts since these are remapped in mswin.vim
nnoremap <C-A-v> <C-v>
nnoremap <C-A-x> <C-x>
nnoremap <C-A-z> <C-z>

" When deleting single characters, don't bother to copy them to clipboard.
nnoremap x "_x
nnoremap X "_X
nnoremap s "_s
nnoremap S "_S

" Make these work in Normal mode:
nnoremap <BS> "_d<left><insert>
nnoremap <Return> i<CR>

nnoremap <A-BS> "_db
" Both C-BS:
nnoremap <C-BS> "_db
nnoremap <ESC>[127;5u <C-BS> "_db

nnoremap <C-Home> gg0
nnoremap <C-End> G$

" Keep the cursor in place when you join lines with J, you can do this,
" dropping a mark before the operation to which you return afterwards:
nnoremap J mzJ`z

" Insert newline while staying current line.
nnoremap oo o<Esc>k

" Visual line nav, not real line nav. If you wrap lines, vim by default won't
" let you move down one line to the wrapped portion. This fixes that.
nnoremap <Down> gj
nnoremap <Up> gk

" Scroll without moving cursor.
noremap <C-Up> <C-y>
noremap <C-Down> <C-e>
noremap <C-k> <C-y>
noremap <C-j> <C-e>

" Insert single character. Can be repeated with . or added count.
function! RepeatChar(char, count)
  return repeat(a:char, a:count)
endfunction
nnoremap + :<C-U>exec "normal i".RepeatChar(nr2char(getchar()), v:count1)<CR>
" nnoremap S :<C-U>exec "normal a".RepeatChar(nr2char(getchar()), v:count1)<CR>

" Clear highlighting, update diff, redraw screen.
inoremap <C-l> <C-o>:nohlsearch<BAR>diffupdate<CR><C-o><C-l>
nnoremap <C-l> :nohlsearch<BAR>diffupdate<CR><C-l>

" --- Function keys ----

" Function keys
call MapAll('<F3>','n')

" Reload file
call MapAll('<F5>',':edit!<CR>')

" Sitch to paste mode, disabling all kinds of smartness and just pasting
" a whole buffer of text.
set pastetoggle=<F8>

if has('gui')  " Toggle toolbar (Gvim)
  nnoremap <Leader>tt :if &go=~#'T'<Bar>set go-=T<Bar>else<Bar>set go+=T<Bar>endif<CR>
endif

" Toggle relative / nonrelative line numbers
call MapAll('<F11>',':set invrelativenumber<CR>')

" Edit and source (P)references (vimrc)
call MapAll('<C-A-p>',':edit $DOTFILES/vim/vimrc<CR>')
call MapAll('<F12>',':source $DOTFILES/vim/vimrc<CR>')

" Tabs
nnoremap <Leader>t :tabnew<CR>
nnoremap <Leader>w :tabclose<CR>

" Change window
call MapAll('<A-h>','<C-w>h')
call MapAll('<A-j>','<C-w>j')
call MapAll('<A-k>','<C-w>k')
call MapAll('<A-l>','<C-w>l')

call MapAll('<A-Left>','<C-w>h')
call MapAll('<A-Down>','<C-w>j')
call MapAll('<A-Up>','<C-w>k')
call MapAll('<A-Right>','<C-w>l')

call MapAll('<A-1>','1gt')
call MapAll('<A-2>','2gt')
call MapAll('<A-3>','3gt')
call MapAll('<A-4>','4gt')
call MapAll('<A-5>','5gt')
call MapAll('<A-6>','6gt')
call MapAll('<A-7>','7gt')
call MapAll('<A-8>','8gt')
call MapAll('<A-9>','9gt')

"D deletes from the cursor to the end of the line; C changes from the cursor to
"the end of the line. But Y yanks the entire line. Fix to yank to the end of line.
nnoremap Y y$

" qq to record, Q to replay
nnoremap Q @q

" Select all text
nnoremap vA ggVG

" Open/close folding
nnoremap <Space> za<CR>

" Make use of 'ö' as $.
noremap ö $
nnoremap cö c$
nnoremap dö d$
nnoremap yö y$
nnoremap vö v$
" nmap gö $
" nmap 0 g0
" nmap g0 0
" tai
" nmap ö $
